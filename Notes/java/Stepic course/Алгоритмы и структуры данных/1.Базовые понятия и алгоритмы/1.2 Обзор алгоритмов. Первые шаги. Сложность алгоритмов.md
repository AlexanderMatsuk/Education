**Алгоритм** - формально описанная вычислительная процедура, получающая исходные данные (input), называемые так же входом алгоритма или его аргументом, и выдающая результат вычисления на выход (output).

```
output функция (input) {
  процедура;
}
```

**Структура данных** - программная еденица, позволяющая хранить и обрабатывать множество однотипных и/или логически связанных данных.

Типичные операции:
* добавление данных
* изменение данных
* удаление данных
* поиск данных

**Обзор основных алгоритмов и структур данных**
* Стандартные операции с массивом
1. Доступ к элементам по индексу. Изменение элементов.
2. Линейный (последовательный) поиск.
3. Бинарный поиск.

* Сортировка массива
1. Сортировка вставками, сортировка пузырьком, сортировка выбором.
2. Сортировка слиянием.
3. Быстрая сортировка. 
4. Пирамидальная сортировка.
5. Поразрядные сортировки.
6. TimSort

* Базовые структуры данных
1. СД "Динамический массив"
2. СД "Однонаправленный список" и "Двунаправленный список"
3. СД "Стек"
4. СД "Очередь"
5. СД "Дек"
6. СД "Двоичная куча"
7. АТД "Очередь с приоритетом"

* Деревья
1. СД "Двоичное дерево"
- Алгоритмы обхода дерева в ширину и в глубину
2. СД "Дерево поиска". Сбалансированные деревья.
- СД "Декартово дерево"
- СД "АВЛ дерево"
- СД "Красно-черное дерево"
- СД "Сплей дерево"
- АТД "Ассоциативный массив"
3. СД "Дерево отрезков"
4. СД "В-дерево"

* Хеширование
1. Алгоритмы вычисления хеш-функций
- Хеш-функция для строк.
2. СД "Хэш-таблица"
- Реализация хеш-таблицы методом цепочек.
- Реализация хеш-таблицы методом открытой адресации.
3. Блюм-фильтр

* Графы
1. Обходы в ширину и глубину
2. Топологическая сортировка
3. Поиск сильносвязанных компонент
4. Поиск кратчайших путей между вершинами 
5. Поиск Эйлерова пути
6. Поиск Гамильтонова пути минимального веса. Задача коммивояджера. 
7. Нахождение основного дерева минимального веса.
8. Вычисление максимального потока в сети.
9. Нахождение наибольшего паросочетания в двудольном графе.
10. Вычисление хроматического числа графа.

* Строки
1. Потск подстрок
- Алгоритм Кнута-Морриса-Пратта
- Алгоритм Ахо-Карасик
2. Индексирование текста
- Бор
- Суффиксный массив
- Суффиксное дерево
- Суффиксный автомат
3. Ренгулярные выражения
4. Вычисление редакторского расстояния между строками

* Вычислительная геометрия
* Теория игр
* Полиномы и быстрое преобразование Фурье
* Матрицы
* Алгоритмы сжатия
* Численные методы решения уравнений
* Машинное обучение
 
## Анализ алгоритмов
Эффективность алгоритма определяется:
* Временем работы
* Объемом дополнительно используемой памяти 
* Другими характеристиками. Например, количеством операций сравнения (сортировка) или количеством обращений к диску (например в БД)
 
Характеристика данных - число n или несколько чисел.
Время работы - T(n)
Объем дополнительной памяти - M(n)

Пример 1. Сортировка массива слиянием.
T(n) ≈ n * log n - Можно сказать, что T(n) - функция, которая принадлежит O(n * log n), Ø(n * log n)
M(n) ≈ n - принадлежит классу O(n), Ø(n) 

### Асимптотические обозначения
Для обозначения асимптотического поведения времени работы алгоритма (или объема памяти) используются Θ, O и Ω – обозначения.
Определение. 
Для функции g(n) записи Θ(g(n)), O(g(n)) и Ω(g(n)) означают следующие множества функций:

Θ(g(n))={f(n):∃c1>0,c2>0,n0>0,такие что ∀n≥n0 O≤c1⋅g(n)≤f(n)≤c2⋅g(n)},

O(g(n))={f(n):∃c>0,n0>0,такие что ∀n≥n0 O≤f(n)≤c⋅g(n)} 

Ω(g(n))={f(n):∃c>0,n0>0,такие что ∀n≥n0 O≤c⋅g(n)≤f(n)} 

**Пояснение к формулам** 
O(g(n)) означает множество функций f, для каждой из которых существует (своя) константа c, такая что начиная с некоторого n0 выполняется: f(n) неотрицательна и ограничена сверху c⋅g(n).
Аналогично Ω(g(n)) – класс функций, ограниченных снизу, Θ(g(n)) – класс функций, ограниченных и снизу, и сверху.

Обозначение. Вместо записи «T(n)∈Θ(g(n))» часто используют запись «T(n)=Θ(g(n))».

По простому: O - верхняя граница (меньше или равно), т.е. данная функция не может расти быстрее с точностью до константы. Θ - точная граница (равно), т.е. данная функция растёт точно так же с точностью до константы. Ω - нижняя граница (больше или равно), т.е. данная функция растёт не медленнее с точностью до константы.

**Ссылки по теме**
* [Введение в анализ сложности алгоритмов (часть 1)](http://habrahabr.ru/post/196560/)
* [Введение в анализ сложности алгоритмов (часть 2)](http://habrahabr.ru/post/195482/)

### Числа Фибоначи
Задача: Найти n-ое число Фибоначи
1) F0 = 0
2) F1 = 1
3) Fn = (Fn-1) + (Fn-2)

**Рекурсивный подход**
int fibonachi (int n) {
  if (n == 0 || n == 1) {
    return 1;
  }
  return fibonachi (n - 1) + fibonachi (n - 2);
}

Сложность: 
Время работы - T(n) = Ω(золотое сечение^n)
Объем дополнительной памяти - M(n) = O(n) - максимальная глубина рекурсии

**Нерекурсивный алгоритм**
int fibonachi (int n) {
  if (n == 1) {
     return 1;
  }
  int prev = 1; // F(0)
  int current = 1; // F(1)
  for (int i=2; i<= n; ++i) {
    int temp = current;
    current += prev; // Вычисление F(i)
    prev = temp; // Запоминаем F(i-1)
  }
  return current;
}

Сложность:
Время работы - T(n) = O(n) - количество итераций в цикле
Объем дополнительной памяти - M(n) = O(1)

### Проверка числа на простоту 
Задача. Является ли натуральное число n простым?
Варианты решения:
1) Можем быстро определять, делится ли одно натуральное число (n) на другое (k).
Проверять остаток от деления - n % k == 0
Будем проверять все числа n и если условие не выполняется, то n - простое число.

2) Можно перебирать только от 1 до √n
n = a * b
Если мы найдем такое a ≥ √n, то b ≤ √n

bool isPrime (int n) {
  if (n == 1) {
    return false;
  }
  for (int i = 2; i*i <= n; ++i) {
    if (n % i == 0) {
      return false;
    }
  }
  return true;
}

Время работы - T(n) = O(√n) потому что количество итераций цикла у нас √n
Объем дополнительной памяти - M(n) = O(1)

### Массивы
Определение 1. Массив - набор однотипных компонентов (элементов), расположенных в памяти непосредственно друг за другом, доступ к которым осуществляется по индексу. 
Определение 2. Размерность массива - количество индексов, необходимое для однозначного доступа к элементу массива.

В С и С++ для передачи массива в функцию можно передать указатель на начало массива и количество элементов.

### Массивы. Линейный поиск.
Задача 1. Проверить есть ли заданный элемент в массиве (или найти его).
Решение. Последовательно проверяем все элементы массива, пока не найдем заданный элемент, либо пока не закончится массив.
Сложность: T(n) = O(n)
Решение на С++

bool HasElement (const double* arr, int count, double element) {
  for (int i=0; i<count; i++) {
    if (arr[i] = element) {
      return true;
    }
  }
  return false;
}

Задача 2. Найти максимальный элемент в массиве. Вернуть его значение.
Решение. Последовательно проверяем все элементы массива, заполняем текущее значение максимума.
Сложность: T(n) = O(n)
Решение на С++

double MaxElement (const double* arr, int count) {
  // число элементов должно быть больше 0
  assert (count > 0)
  double curentMax = arr [0];
  for (int i=0; i<count; i++) {
    if (arr[i] > currentMax) {
      currentMax = arr[i];
    }
  }
  return currentMax;
}

### Массивы. Бинарный поиск. 
**Определение.** Упорядоченный по возрастанию массив - массив А, элементы которого сравнимы, и для любых индексов k и l, k < l; A[k] < A[l].
Упорядоченный по убыванию массив определяется аналогично. 

**Задача.** Проверить есть ли заданный элемент в упорядоченном массиве. Если есть, то вернуть позицию его первого вхождения. Если нет, то вернуть -1.
**Решение. (Бинарный поиск = Двоичный поиск)** Шаг. Сравниваем эдемент в середине массива (медиану) с заданным элементом. Выбираем нужную половину массива в зависимости от результатов сравнения. Повторяем этот шаг до тех пор, пока размер массива не уменьшиться до 1.

**Итеративное решение задачи**

    public static int getIndexBynarySearch(int searchItem, int... array) {
	 Arrays.sort(array);

        int first = 0;
        int count = array.length;
        int last = count;

        while (first < last) {
            int mid = (first + last) / 2;
            if (searchItem <= array[mid]) {
                last = mid;
            } else {
                first = mid + 1;
            }
        }
        return (first == count || array[first] != searchItem) ? -1 : first;
    }

**Рекурсивное решение задачи**

    // возвращаем позицию вставки элемента на отрезке (first, last)
    private static int findInsertionPoint(double[] arr, int first, int last, double element) {
        if (first == last) {
            return first;
        }
        int mid = (first + last) / 2;
        if (element <= arr[mid]) {
            return findInsertionPoint(arr, first, mid, element);
        } else {
            return findInsertionPoint(arr, mid + 1, last, element);
        }
    }

    // возвращает позицию элемента в упорядоченном массиве, если такой элемент есть
    // возвращает -1, если такого элемента нет.
    public static int binarySearch(double[] arr, double element) {
        Arrays.sort(arr);
        int point = findInsertionPoint(arr, 0, arr.length, element);
        return (point == arr.length || arr[point] != element) ? -1 : point;
    }
 





